from bs4 import BeautifulSoup as bs
from test import *
from aiohttp import web
import logging.handlers
import subprocess
import requests
import aiohttp
import base64
import json

url = 'http://127.0.0.1'
e_mail = ''
password = 'qweqweqweqwe'
IP = ''

# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  logging  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

console = logging.StreamHandler()
console.setLevel(logging.INFO)
formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
console.setFormatter(formatter)
logfile = logging.handlers.RotatingFileHandler("server.log", maxBytes=1024 * 1024, backupCount=5)
logfile.setLevel(logging.INFO)
logfile.setFormatter(formatter)
logging.basicConfig(level=logging.INFO, handlers=[console, logfile])

# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  logging  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  VW autorization  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tkn_session_str = reload_auth()


# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  VW autorization  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

class Vaultwarden:
    routes = web.RouteTableDef()

    def __init__(self):
        self.config_server()
        self.auth = self.get_auth()

    '''Login/logout'''

    def get_auth(self):  # authorization
        def login():
            result = str(subprocess.check_output(
                f'bw login {e_mail} {password}', shell=True))
            print(result)
            session = result.split('--session ')[-1].replace('\'', '')
            return session

        try:
            return login()
        except subprocess.CalledProcessError:
            self.config_server()
            self.logout()
            return login()

    def logout(self):  # logout
        subprocess.check_output('bw logout', shell=True)

    def config_server(self):  # CLI settings
        subprocess.check_output(f'bw config server {url}', shell=True)

    '''Return info'''

    async def get_org_id(self, request):
        org_id = str(subprocess.check_output(f'bw list organizations --session {self.auth}',
                                             shell=True)).split(':')
        org_id = org_id[2].split(',')[0]
        org_id = org_id.replace('"', '')
        return org_id

    async def get_members(self, request):
        page = requests.get('http://127.0.0.1/admin/users/overview',
                            headers={"Cookie": f"VW_ADMIN={tkn_session_str}"})
        list_members = []
        soup = bs(page.text, 'html.parser')
        table = soup.find('table')
        result = table.find_all('div', 'overflow-auto vw-org-cell')
        for j in result:
            list_members.append({"email": j['data-vw-user-email'],
                                 "user_id": j['data-vw-user-uuid'],
                                 "org_data": [button.get('data-vw-org-uuid')
                                              for button in j.find_all('button')]})
        return list_members

    async def get_organization(self, request):
        page = requests.get('http://127.0.0.1/admin/organizations/overview',
                            headers={"Cookie": f"VW_ADMIN={tkn_session_str}"})
        list_organizations = []
        soup = bs(page.text, 'html.parser')
        table = soup.find('table')
        result = table.find_all('button')
        for j in result:
            list_organizations.append({"name": j['data-vw-org-name'],
                                       "email": j['data-vw-billing-email'],
                                       "org_id": j['data-vw-org-uuid']})
        return list_organizations

    async def info_collections(self, request):
        org_id = await self.get_org_id(request)
        page = requests.get(f'http://127.0.0.1/api/organizations/{org_id}/users?includeCollections=true',
                            headers={"Authorization": tkn})
        lst_collections = []
        for i in page.json()['Data']:
            lst_collections.append({'Name': i['Name'],
                                    'User_Id': i['UserId'],
                                    'Email': i['Email'],
                                    'Groups': i['Groups'],
                                    'Collections': i['Collections']})
        return lst_collections

    async def get_collections(self, request):
        org_id = await self.get_org_id(request)
        dct = {}
        collections = json.loads(subprocess.check_output(f'bw list org-collections'
                                                         f' --organizationid {org_id}'
                                                         f' --session {self.auth}', shell=True))
        for item in collections:
            dct[item['id']] = (item['name'], org_id)
        return dct

    # async def get_members(self, request):  # member collection's info
    #     org_id = await self.get_org_id(request)
    #     info = subprocess.check_output(f'bw list org-members'
    #                                    f' --organizationid {org_id}'
    #                                    f' --session {self.auth}', shell=True)
    #     dct_info = {}
    #     for item in json.loads(info):
    #         dct_info[item['name']] = (item['email'], item['id'])
    #     return dct_info

    '''Create'''

    async def create_collection(self, data):  # create a new collection
        bw = json.loads(subprocess.check_output
                        (f'bw get template org-collection'
                         f' --session {self.auth}', shell=True))
        bw['organizationId'] = data["org_id"]
        bw['name'] = data["name"]
        bw['groups'] = []
        item = subprocess.check_output(
            f"bw create org-collection {base64.b64encode(bytes(json.dumps(bw), encoding='utf-8')).decode('utf-8')}"
            f" --organizationid {data['org_id']} --session {self.auth}", shell=True)
        item = json.loads(item)
        dct_1 = {item['id']: (item['name'], item['organizationId'])}
        async with aiohttp.ClientSession() as session:
            async with session.post(
                    f'http://{IP}/service_vaultwarden/update_collections', json=dct_1) as response:
                response_data = await response.json()
        return True

    '''Delete'''

    async def delete_user(self, user_id):  # delete user
        requests.post(f'http://127.0.0.1/admin/users/{user_id}/delete',
                      headers={"Cookie": f"VW_ADMIN={tkn_session_str}"})
        return True

    async def delete_organization(self, id_org):  # delete organization
        requests.post(f'http://127.0.0.1/admin/organizations/{id_org}/delete',
                      headers={"Cookie": f"VW_ADMIN={tkn_session_str}"})
        return True

    async def delete_collection(self, data):  # delete collection
        subprocess.check_output(
            f'bw delete org-collection {data["col_id"]}'
            f' --organizationid {data["org_id"]}'
            f' --session {self.auth}',
            shell=True)
        return True

    # async def delete_member(self, id_member):  # delete member of organization
    #     subprocess.check_output(
    #         f'bw delete org-member {id_member}  --session {self.auth}',
    #         shell=True)

    '''Return JSON with info'''

    async def update_data(self, request):
        infocols = await self.info_collections(request)
        users = await self.get_members(request)
        cols = await self.get_collections(request)
        orgs = await self.get_organization(request)
        async with aiohttp.ClientSession() as session:
            async with session.post(
                    f'http://{IP}/service_vaultwarden/info_collections', json=infocols) as response:
                await response.json()
            async with session.post(
                    f'http://{IP}/service_vaultwarden/update_users', json=users) as response:
                await response.json()
            async with session.post(
                    f'http://{IP}/service_vaultwarden/update_collections', json=cols) as response:
                await response.json()
            async with session.post(
                    f'http://{IP}/service_vaultwarden/update_organizations', json=orgs) as response:
                await response.json()
        return True

    '''Function's manager'''

    async def task_maker(self, request):  # getting JSON / returns a func
        print('Working')
        data = await request.json()
        task = data['args'][0]
        funk = a.__getattribute__(task["action"])
        logging.info(f'processing {task["action"]}')
        res = await funk(task)
        if res:
            logging.info(f"Успешно выполнено {task['action']}")
        else:
            print(f"Не удалось выполнить действие {task['action']},"
                  f" \nПараметры: {str(task)}")


# _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

if __name__ == '__main__':
    a = Vaultwarden()
    app = web.Application()
    app.router.add_route('POST', '/make_task', a.task_maker)
    web.run_app(app, port=9090)

# _____________________________________________________________________________________________________________________
